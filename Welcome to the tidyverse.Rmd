---
title: "Welcome to the tidyverse!"
output: html_notebook
---

**Part of the DGfS PhD students' forum, 23 February 2021**

Instructors: Kyla McConnell and Julia Müller  
Contact us on Twitter (@McconnellKyla, @JuliaMuellerFr)  

Unless indicated, artwork is by the wonderful @allison_horst - find her on [github](https://github.com/allisonhorst/stats-illustrations).


# (1) What is this "tidyverse"?

The tidyverse is an extremely useful collection of R *packages* (i.e. add-ons to *base-R*) that help you get your data into a useful format (among other things).

![The tidyverse](img/tidyverse_celestial.png){width=50%}

**The following packages are included in the tidyverse:**  
- *ggplot2*: for data visualisation  
- *tibble*: for tweaked dataframes  
- *tidyr*: for data wrangling  
- *readr*: for reading in files  
- *purrr*: for functional progamming  
- *dplyr*: for data manipulation  
- *stringr*: for string manipulation  
- *forcats*: for working with categorical variables (factors)  


## What is tidy data, and why do we use it?

**Characteristics of tidy data:**  

![What does tidy data look like?](img/tidydata_1.jpg){width=50%}

**Why this format?**  
- a lot of wrangling commands are based on the assumption that your data is tidy 
- is expected for many statistical models
- works best for plotting 
- "Tidy datasets are all alike, but every messy dataset is messy in its own way" Hadley Wickham

![Why use tidy data?](img/tidydata_3.jpg){width=50%}


# (2) R basics

## Installing and loading packages

- Install a new package with `install.packages("PACKAGENAME")` or through the Packages pane (bottom right) - only if you haven't used a package before
- Every time you start a new R session, load the package(s) you need with `library()` near the top of the script

```{r loading packages}
library(tidyverse)
```
As you can see when loading the tidyverse package, it's actually a family/collection of packages.


## Variables

Variables: give name/label to output, saves it (can be used anywhere below in current script)

name_of_variable <- code

For example:
```{r}
fav_number <- 12

fav_number * 3

worst_number <- 7

difference <- fav_number - worst_number

difference
```

## Data types

- Data types -- how R interprets the input you give it
- Figure out what type something is with `class()` 

```{r}
class(8.8)

class(double_number)
```

- Numbers generally treated as *numeric* -> can include decimals 

- *integer* allows only whole numbers -> can force numbers into this form with `as.integer()`
  - this will truncate the decimal (cut it off), not round
  - round with `round()`

```{r}
as.integer(8.8)

integer_variable <- as.integer(8.8)
integer_variable

class(integer_variable)

round(8.8)
```

- *character* is text, always enclosed in either double or single quotation marks 

```{r}
class('hello')
```

- *logical* can be either TRUE or FALSE, nothing else. 

test if something is identical with ==
test if something is not identical with !=
test if something is greater than with > or less than with <
or try greater than or equals to >= or less than or equal to with <=

```{r}
7 < 8

"dog" == "dogs"

8.8 >= 5.6

logic_test <- "seven" == 7

class(logic_test)
```

*factor* - string variables that should be treated as categories / distinct levels of a grouping -> will become more relevant when we work with datasets


## Vectors

Special variable type: *vector* -- contains multiple items of the same type, enclosed in the syntax `c()`

- command `length()` returns number of items in the vector

```{r}
grocery_list <- c("apples", "bananas", "bread", "orange juice")

length(grocery_list)
```

You can also do "vector-wise" operations:
```{r}
my_numbers <- c(12, 14, 26, 57, 82)

my_numbers + 2
```

Mathematical operation is "broadcast" to each item

Add/subtract/multiply/divide a vector by another vector: items matched up one at a time in a loop

You can also take a certain item from a vector using square brackets. For example, take the first item:

```{r}
my_numbers[5]
```


# (3) Communicating with R

## Understanding warnings and errors
R will often "talk" to you when you're running code. For example, when you install a package, it'll tell you e.g. where it is downloading a package from, and when it's done. Similarly, when you loaded the tidyverse collection of packages, R listed them all. That's nothing to worry about!

When there's a mistake in the code (e.g. misspelling a variable name, forgetting to close quotation marks or brackets), R will give an *error* and be unable to run the line. The error message will give you important information about what went wrong.
```{r}
hello <- "hi"
Hello
```

In contrast, *warnings* are shown when R thinks there could be an issue with your code or input, but it still runs the line. R is generally just telling you that you MIGHT be making a logical error, not that the code is impossible.

```{r}
c(1, 2, 3) + c(1, 2)
```


## Reading function documentation
We'll get to know a number of R *functions* today. These functions can take one or more `arguments`. As an example, let's try out the `say()` function from the cowsay package.

First, (install and) load the cowsay package:
```{r}
# install.packages("cowsay")
library(cowsay)
```

Try the following code:
```{r}
say(
  what = "Good luck learning R!", 
  by = "rabbit")
```

We can see that this function has the `what` argument (what should be said?) and the `by` argument (which animal should say it?). But what other options are there for this command - which other animals, for example, or can you change the colour? To see the documentation for the `say` command, you can either run this line of code:
```{r}
?say
```
...or type in `say` in the Help tab on the bottom right.

This will show you the documentation for the command.

- *Usage* shows an overview of the function arguments and their defaults (e.g. if you typed in `say()` without any arguments in the brackets, you'd get the defaults, i.e. a cat saying "Hello world!")
```{r}
say()
```

- *Arguments* provides more information on each argument. 
Arguments are the options you can use within a function.
- what
- by 
- type
- what_color
etc. 
Each of these can be fed the `say()` function to slightly alter what it does.

- *Examples* at the bottom of the help page lists a few examples you can copy-paste into your code to better understand how a function works.

Don't worry if you don't understand everything in the documentation when you're first starting out. Just try to get an idea for which arguments there are and which options for those arguments. It's good practice to look at help documents often -- this will also help you get more efficient at extracting the info you need from them.

### Try it out
Call the `say()` function including the arguments what, by, and what_color. Try at least a few different options for each of these and find your favorite look. Try using "random" with the argument "by" or "catfact" or "fortune" with the argument "what".
```{r}

```


# (4) Reading in data
What type of file are you working with? Specifically, what's used to separate the values in the different columns? To find out, open the file in a text editor. Common options are either commas or semicolons (in which cases, the file often has the ending .csv) or tabs (often .txt files).
Where is the file saved? If you are working in a Markdown and the data file is saved in the same location as the script file, you can use the name of the file with its ending, e.g. "new_data.csv" or "final_data.txt". This is possible because RMarkdown automatically sets the working directory, i.e. the location R tries to find the file, to where it is saved. This is very convenient especially when you share your script and data. Your contributor doesn't need to type in any long paths but can directly start working.
If the file is saved in a subfolder called "data", use  "data/example_file.csv"). ../ allows you to go backwards one folder.

If you're working in a script, use `setwd()` (e.g.: `setwd(~Documents/PhD/Rscripts/...)` or `setwd(C:/Documents...)`), or Session -> Set Working Directory -> Choose Directory...)

The commands to read in a file are:
- base-R: `read.csv()` and `read.tsv()`
  - tidyverse (improvements, reads as tibble instead of dataframe): `read_csv()` and `read_tsv()`
    - must have tidyverse installed and loaded with a `library()` call
    - `read_csv2()` for semicolon-separated csv 
    - `read_delim(file, delim)` for any other delimiters
    
*Save the output to a variable using <- *

So reading in data tends to follow this pattern:
```{r eval=FALSE}
name_of_data_in_R <- read_csv("data_file.csv") # equivalent to
name_of_data_in_R <- read_delim("data_file.csv", delim = ",")

name_of_data_in_R <- read_csv2("data_file.csv") # equivalent to
name_of_data_in_R <- read_delim("data_file.csv", delim = ";")

name_of_data_in_R <- read_tsv("data_file.txt") # tab-separated file
```


#### A note on the data we'll use today
We've tried to tailor the workshop to be relevant to the kinds of data many of you said you used in the pre-workshop survey, so we'll start with self-paced reading data (which looks fairly similar to eye-tracking data, another common response), and later use examples of corpus data and a questionnaire output. However, everything we discuss is useful for any kind of data!
We're also providing several files for you to practise on later, so you can pick data that looks closest to what you're actually working with.

Let's read in a small self-paced reading dataset (saved in the data folder, so we need to add `data/` to tell R that):
```{r}
spr_data <- read_csv("data/spr_example.csv")
```

## Dataframes and tibbles: What's the difference?
We already know one command set from the tidyverse: `read_csv()` and `read_tsv()`. These are used to read in data, and they return a structure called the "tibble". 

The tibble is the "tidyverse" version of the base-R alternative, the "data.frame". 

In practice, "data.frame"s and "tibble"s are very similar, however:
- tibbles print a few rows as default
- tibbles are made to work with the tidyverse calls to come
- tibbles don't automatically read in text columns as factors (sounds like a disadvantage but is often an advantage, more on this later)
- tibbles doesn't restrict or change column names -- if they are invalid (have spaces, start with whitespace), they can still be called, you just have to surround them with backticks ``

That's probably enough info for now, but if you want to read more about tibbles as you get more comfortable with R, here is a chapter in R for Data Science: 
https://r4ds.had.co.nz/tibbles.html


# (5) Exploring our data

Now you have a data file read in, but how do you see what's in it?

```{r}
head(spr_data)
```

You can change the amount of rows with the `n` *argument*: 
```{r}
head(spr_data, n=3)
```

Or: click name of dataframe in Environment tab
  - can also sort columns and Filter rows -- just for viewing purposes
  - bit slow if you start having huge dataframes but often a good first look

`summary()`: call it on a dataframe to get each column and useful info based on the data type. For example, numeric columns will show the min, median, max and the quartiles (25% increments).
```{r}
summary(spr_data)
```

#### Try it out - delete?

1. Load in the dataframe "spr_example.csv" as a tibble, i.e. using the tidyverse call `read_csv()` Make sure to save it to a variable.
2. Take a look at your dataframe in the Environment tab. 
3. Try the command `colnames()` on the variable you saved the dataframe to. What does it do?
4. We already tried the `head()` command, now try the `tail()` command. What does it do?


# (6) The pipe %>% 

One of the most noticeable features of the tidyverse is the pipe %>% (keyboard shortcut: Ctr/Cmd + Shift + M) .

The pipe takes the item before it and feeds it to the following command as the first argument. Since all tidyverse (and some non-tidyverse) functions take the dataframe as the first argument, this can be used to string together multiple functions. 

So to re-write the `head()` function with the pipe:
```{r}
spr_data %>% 
  head()
```

This produces the exact same output as `head(spr_data)`. Why would this be useful?

Compare the following lines of pseudocode, which would produce the same output:

A.
bop(
  scoop(
    hop(foo_foo, through = forest),
    up = field_mice
  ), 
  on = head
)


B.
foo_foo %>%
  hop(through = forest) %>%
  scoop(up = field_mice) %>%
  bop(on = head)
  
You can see that the version with the pipe is easier to read when more than one function is called on the same dataframe! 

Here are some more examples:
```{r}
# Equivalent to summary(spr_data)
spr_data %>% 
  summary()


# Equivalent to colnames(spr_data), which returns all column names
colnames(spr_data)

spr_data %>% 
  colnames() 

# Equivalent to nrow(spr_data), which returns the number of rows in the df
nrow(spr_data)

spr_data %>% 
  nrow()
```

And you can also stack commands by ending each row (except the last one) with a pipe:
```{r}
spr_data %>% 
  colnames() %>% #extracts column names
  toupper() #converts them to uppercase

spr_data %>% 
  colnames() %>% #extracts column names
  nchar() #counts the number of letters
```


# (7) Changing columns

## (7.1) rename()
You can rename columns with the `rename()` function. The syntax is new_name = old_name. Let's rename the `cond` variable:
```{r}
spr_data %>% 
  rename(condition = cond)
```

You can also rename multiple columns at once (no need for an array here):
```{r}
spr_data <- spr_data %>% 
  rename(condition = cond, 
         sentence = full_sentence)
```
Notice above that I've saved output over the spr_data dataframe to make the changes 'permanent'.


## (7.2) relocate()

![Relocate](img/dplyr_relocate.png){width=50%}

The `relocate` function lets you change the order of variables in the data. The following command moves the participant id, full sentence, and word to the beginning: 
```{r}
spr_data %>% 
  relocate(participant, sentence, word)
```

You can also specify that a variable should be placed before or after another variable:
```{r}
spr_data %>% 
  relocate(word_num, .after = word) %>% 
  relocate(sentence, .before = sentence_num)
```

Another option is to sort by data type, e.g. if you'd like all character variables to be shown first:
```{r}
spr_data %>% 
  relocate(where(is_character))
```
Other options: is_numeric for numbers, is_factor?

This is particularly useful if you have large datasets with lots of variables.

## (7.3) select()

- The traditional syntax for dealing with columns is dataframe$column.

A useful step in using pipes and tidyverse calls is the ability to *select* specific columns. That is, instead of writing `spr_data$category` we can write:

```{r}
spr_data %>% 
  select(category) 
```

We can then use this column for further calculations, like piping it on to the summary call. This will provide the same result as `summary(spr_data$price)`
```{r}
spr_data %>% 
  select(price) %>% 
  summary()

spr_data %>% 
  select(price) %>% 
  max()

spr_data %>% 
  select(height) %>% 
  min()
```

We could, for example, look at the tallest item:
```{r}
spr_data %>% 
  select(height) %>% 
  max()
```

Or the thinnest:
```{r}
spr_data %>% 
  select(width) %>% 
  min()
```


### Select multiple columns 
You can also use `select()` to take multiple columns. 

```{r}
spr_data %>% 
  select(name, price, category)
```

You can see that these columns are presented in the order you gave them to the select call, too:

```{r}
spr_data %>% 
  select(category, price, name)
```

You can also use this to reorder columns in that you give the name of the column(s) you want first, then finish with `everything()` to have all other columns follow:

```{r}
spr_data %>% 
  select(price, everything())
```

#### Try it out 

1. We tried piping spr_data to `head()` above. Try it now with `tail()`. What does this show you? 
```{r}

```

2. Pipe the 'spr_data' dataset to `colnames()` What does this command do? (Bonus, pipe the columnn names on to the `nchar()` function and figure out what that does.)
```{r}

```

3. What is the shortest item in the dataset? The widest?
```{r}

```

4. Select the depth column and pipe it to `range()` to see the full rannge of depths.
```{r}

```


### Preview vs. saving
- Above: mostly previewing using `select()` for first insights
  - if you look at the spr_data dataframe, for example in the Environment panel on the upper-right, the dataframe hasn't changed

- To save your changes: assigning your call back to the variable name

- Good work flow: Preview then save when you're sure you're happy with the output

```{r}
spr_data %>% 
  select(name, everything())
```

```{r}
spr_data <- spr_data %>% 
  select(name, everything())
```

There is no output here, but the spr_data dataframe has been permanently updated (within the R session, not in your file system)

There is also a trick to show a preview and save it to the variable -- wrapping the whole call in parentheses -- use with caution!

```{r}
(spr_data <- spr_data %>% 
  select(name, everything()))
```

If you make a mistake: arrow with a line under it in the code block of R-Markdown, runs all blocks above (but not the current one)


### Remove columns with select

You can also remove columns using select if you use the minus sign. For example, here, we have the first column ("X1") which is a sort of row numbering. If you don't want this column, you can drop it with select:

```{r}
spr_data %>% 
  select(-X1)
```

You can also remove multiple columns at once by writing them in an array `c()`. Once your preview looks the way you want it --just make sure to save your results by committing it to a variable (over the old one is fine).

```{r}
(spr_data <- spr_data %>% 
  select(-c(X1, old_price)))
```

### Leveling up select()

Until now, we've used select() in combination with the full column name, but there are helper functions that let you select columns based on other criteria.

For example, here's how we can select both the `price` and the `old_price` column - by specifying `ends_with("price")` in the select() call:
```{r}
spr_data %>% 
  select(ends_with("price"))
```

The opposite is also possible, e.g.
```{r}
spr_data %>% 
  select(starts_with("s"))
```
returns all columns that start with "s".

`contains` is another helper function. Here, we're using it to show all columns that contain an underscore:
```{r}
spr_data %>% 
  select(contains("_"))
```

If we try to select a column that doesn't exist, we get an error message:
```{r}
# spr_data %>% 
#  select(name, translation)
```

But if we combine select with any_of, we don't see an error. Instead, R just returns the columns that do exist:
Note here that you have to use an array and enclose the names in quotes!
```{r}
spr_data %>% 
  select(any_of(c("name", "translation")))
```

We can also select a range of  variables using a colon. This works both with variables and (a range of) numbers:
```{r}
spr_data %>% 
  select(X1:category)

spr_data %>% 
  select(1:3) # first three columns
```
Here, the order of the columns matters!


Other helper functions are:
- matches: similar to contains, but can use regular expressions
- num_range: in a dataset with the variables X1, X2, X3, X4, Y1, and Y2, select(num_range("X", 1:3)) returns X1, X2, and X3

#### Try it out
1. From the spr_data dataset, select all columns that start with the letter "d". (Case-sensitive!)

2. Select all the columns of spr_data that contain "th".

3. You would like to buy a really cheap chair -- Filter the dataset to include only chairs that cost less than 100 SAR.

4. Show two different ways to filter the name column to include only items named "BILLY" or "KALLAX".


# (8) Subsets

- Look for rows that fulfill certain conditions

![Filter](img/dplyr_filter.jpg){width=50%}

## (8.1) filter()
### Filter based on a condition
### filter()

Use `filter()` to return all items that fit a certain condition. For example, you can use:
- equals to: ==
- not equal to: !=
- greater than: > 
- greater than or equal to: >=
- less than: <
- less than or equal to: <=
- in (i.e. in a vector): %in%

Syntax: filter(columnname logical-operator condition)

```{r}
penguins %>% 
  filter(bill_length_mm > 55)

penguins %>% 
  filter(bill_length_mm < 35)

penguins %>% 
  filter(bill_depth_mm < 14)
```

You can also select numeric rows with a specific value
```{r}
penguins %>% 
  filter(year == 2009)
```

Or you can use it to select all items in a given category. Notice here that you have to use quotation marks to show you're matching a character string.

Look at the error below:
```{r}
penguins %>% 
  filter(island == Biscoe)
```

The correct syntax is: (because you're matching to a string)
```{r}
penguins %>% 
  filter(island == "Biscoe")

penguins %>% 
  filter(species == "Gentoo")
```

To use %in%, give an array of options (formatted in the correct way based on whether the column is a character or numeric):
```{r}
penguins %>% 
  filter(species %in% c("Gentoo", "Chinstrap"))

penguins %>% 
  filter(year %in% c(2008, 2009))
```
Note that filter is case-sensitive, so capitalization matters.

#### Try it out

1. Load in the spr_example dataset again (update the path if you have to). 
```{r}
spr <- read_csv("data/spr_example.csv") 
```

2. Reading times lower than 150ms are pretty unusual and are sometimes removed from self-paced reading data. You decide that you want to remove these response times from your data. Filter out all RTs below 150ms from the spr dataset and save your result.
```{r}
nrow(spr)

spr <- spr %>% 
  filter(RT >= 150)

nrow(spr)
```

3. You want to take a look at the results from Par_C only: Filter these data points but don't save the result. 
```{r}
spr %>% 
  filter(participant == "Par_C")
```

4. You're not interested in the practice items in the spr dataframe. Filter the dataset to include everything BUT the practice items and save your result.
```{r}
spr <- spr %>% 
  filter(cond != "practice")
```

### Leveling up filter
- %in%  
- < <= > >=  
- is.na(), !is.na()  
- | &  

## (8.2) distinct()

## (8.3) top_n()

sample()?

# (9) Creating and changing columns 

![Mutate](img/dplyr_mutate.png){width=50%}

## (9.1) mutate()

Let's try to make a column where the prices are in euro. We can call this column price_eur. When I checked, 1 Saudi Riyal was equal to 0.22 euro. So we can multiply the price_sar column by 0.22

```{r}
spr_data %>% 
  mutate(threes = 3)

spr_data <- spr_data %>% 
  mutate(price_eur = price_sar * 0.22)
```
Now, there's a new column called price_eur (it's at the very end by default)

You can also save the new column with the same name, and this will update all the items in that column (see below, where I add 100 to every price, but note that I don't save the output)

```{r}
spr_data %>% 
  mutate(price_sar = price_sar + 100)
```

You can even create many new columns at the same time. Here, dropping each new column onto a new line is considered new style (but not necessary!)

For example, if we wanted to represent dimensions as meters instead of cm:
```{r}
spr_data %>% 
  mutate(depth_m = depth/100, 
         height_m = height/100, 
         width_m = width/100)

spr_data %>% 
  mutate(depth_m = depth/100) %>% 
  mutate(height_m = height/100)
```

You can also do operations to character columns; for example, 
```{r}
spr_data %>% 
  mutate(name = tolower(name))
```

### Change data type in a column

- Tibbles read in all text columns as character -- if you want something to be a factor, you have to set this explicitly. 

- Factors represent groups (participant, conditions, etc.)

- When R acknowledges something as a factor, it can see that there are repeated groupings, i.e. that c("US", "US", "UK") has two instances of the grouping "US" and one of the grouping "UK".

- Let's see what happens when we use call summary on a character column:
```{r}
class(spr_data$category)

spr_data %>% 
  select(category) %>% 
  summary()
```

It tells us just that there are 3694 character rows.

In reality, category is a grouping that repeats itself. So let's set it to a factor (and save it!):
```{r}
spr_data <- spr_data %>% 
  mutate(category = as.factor(category))

spr_data$category <- as.factor(spr_data$category)

class(spr_data$category)
```

Now call summary on the category column:
```{r}
spr_data %>% 
  select(category) %>% 
  summary()
```
Now it tells us how many items of each category are present in the dataframe! Factors also have other benefits / allow R to work intuitively with categories -- so converting to factor will enable R to work with this type of column as it should.

Which other columns in this dataframe should be factors?
```{r}
spr_data <- spr_data %>% 
  mutate(other_colors <- as.factor(other_colors),
         designer <- as.factor(designer))

spr_data$designer <- as.factor(designer)

summary(spr_data$designer)
```

Things like a description, or the item names (if they don't repeat much), don't have to be factors but are more intuitive as character columns, since they don't represent groupings.

Check out the changes in the environment panel too. 

Some calls you can use on factor column include:
```{r}
levels(spr_data$category) #Shows which unique groupings exist
levels(spr_data$other_colors)
```

There is also another syntax that does the same job for replacing columns with altered copies. You may like this better -- either works fine! 
spr_data$category <- as.factor(spr_data.category)

If any other columns in your dataframe are read in wrong (for example, if you have a numeric column that looks like: "43", "18" and is being read as a character column) you can convert them with similar syntax: 
`as.numeric()`, `as.character()` etc.

#### Try it out

1. Call summary on the "participant" column of the spr dataframe -- you can do this either the "tidyverse way" with `select()` or with the traditional `$` syntax. What does it show? 
```{r}
spr_data <- read_csv("../data/spr_example.csv")
```

2. Call `class()` on the same column to get the data type. 

3. Now, try changing the column to a factor using `as.factor()`. Remember that you'll have to save this over top of the old variable.
- Change a character column into a factor using `as.factor()` 
  - save over the original column

4. What do `class()` and `summary()` return now?

5. Are there any other columns in the spr dataframe that you think should be represented as factors?



# (10) Summary tables with groupings

### group_by() & summarize()
First, load the spr_data dataset again:
```{r}
spr_data <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-11-03/spr_data.csv') 
```

To look at summary statistics for specific groupings, we have to use a two- (more like three-) step process. 

First, group by your grouping variable using `group_by()`
Then, summarize, which creates a column based on a transformation to another column, using `summarize()` or `summarise()`
Finally, ungroup (so that R forgets that this is a grouping and carries on as normal, with `ungroup()`
  - usually this makes no difference to what you see but is an important fail-safe

You can use multiple different operations in the summarize part, including:
- mean(col_name)
- median(col_name)
- max(col_name)
- min(col_name)

For example, to return the average price in each category:
```{r}
spr_data %>% 
  group_by(category) %>% 
  summarize(mean(price)) %>% 
  ungroup()
```

You can also give a name to your new summary column: 
```{r}
spr_data %>% 
  group_by(category) %>% 
  summarize(avg_price = mean(price)) %>% 
  ungroup()
```

Or further manipulate it:
```{r}
spr_data %>% 
  group_by(category) %>% 
  summarize(avg_price_eur = mean(price) * 0.22) %>% 
  ungroup()
```

For categorical columns, you can also count how many rows are in each category using `count()` instead of `summarize()`

```{r}
spr_data %>% 
  group_by(category) %>% 
  count() %>% 
  ungroup()
```

Similarly, you can use distinct() to return the unique items in the category, for example:
```{r}
spr_data %>% 
  group_by(category) %>% 
  distinct(name) %>% 
  ungroup()

spr_data %>% 
  distinct(name)
```
You can call `distinct()` without an argument, which will make sure that all columns have only unique items, or you can call it on a specific column, which will return only that column and all the unique items in it.

Or both:
```{r}
spr_data %>% 
  group_by(category) %>% 
  distinct(name) %>% 
  count()
```


#### Try it out

1. Starting with the spr dataset, group by participant and use summarize to find the max RT for each participant. 
```{r}
spr %>% 
  group_by(participant) %>% 
  summarize(max(RT)) %>% 
  ungroup()
```

2. With the same dataset, group by condition and return the mean RT for each condition. This is already a first step towards statistical analysis of your data! Do conditions look like they have similar or very different means?
```{r}
spr %>% 
  group_by(cond) %>% 
  summarize(mean(RT)) %>% 
  ungroup()
```


3. Summarize based on condition and count how many full sentences are in each condition. (Here you will realize that this example dataset doesn't make a ton of sense :D)
```{r}
spr %>% 
  group_by(cond) %>% 
  count(full_sentence) %>% 
  ungroup()

spr %>% 
  count(full_sentence)
```


## If-else-statements
Now for something fancy. You can also make new columns based on "if" conditions using the call `ifelse()`. The syntax of ifelse is: ifelse(this_is_true, this_happens, else_this_happens). For example:

```{r}
spr_data %>% 
  mutate(price_categorical = ifelse(price > 2000, "expensive", "not expensive")) %>% 
  select(name, price, price_categorical)
```

Here is another example (notice the output isn't being saved since we don't really need it):
```{r}
spr_data %>% 
  mutate(height_categorical = ifelse(height <= 100, "shorter than 1m", "taller than 1m")) %>% 
  select(name, height, height_categorical)
```

You can also use ifelse on categorical / character columns:
```{r}
spr_data %>% 
  mutate(fav_designer = ifelse(designer == "Carina Bengs", "Yes", "No")) %>% 
  select(name, designer, fav_designer)
```

You can also use this to condense the groups in a certain column. For example, say we want to combine the categories "Beds", "Wardrobes", and "Chests of drawers & drawer units" into one category, "Bedroom":
```{r}
spr_data %>% 
  mutate(new_category = ifelse(category %in% c("Beds", "Wardrobes","Chests of drawers & drawer units"), "Bedroom", category)) %>% 
  select(item_id, category, new_category)
```
Notice here that if we want to affect the entry only if the condition is TRUE, leaving it unchanged if it is false, we leave the column name as the else condition. This tells R to take the value that is currently in that column if it finds the condition to be FALSE.

We can use the same idea in-place, replacing the existing column, by just assinging it to the identical column name:
```{r}
spr_data %>% 
  mutate(category = ifelse(category %in% c("Beds", "Wardrobes","Chests of drawers & drawer units"), "Bedroom", category))
```

Finally, this is pretty complicated so get ready, you can also combine multiple ifelse statements. Try to follow the logic below:

```{r}
spr_data %>% 
  mutate(category = ifelse(category %in% c("Beds", "Wardrobes","Chests of drawers & drawer units"), "Bedroom", 
                          ifelse(category %in% c("Cabinets & shelving units", "Café furniture"," Chairs"), "Kitchen", "Other")))

penguins %>% 
  mutate(categorical_weight = ifelse(body_mass_g > 3000, "chunky",
    ifelse(body_mass_g > 2000, "normal",
           ifelse(flipper_length_mm > 200, "long fins", 
      "small")
  )))
```

Most of the examples above involve labeling different groupings with text, but you can use ifelse for all sorts of operations. Say the price of wood has gone up, so we want to add 100SAR to the price of any furniture taller than 1m. We could:
```{r}
spr_data %>% 
  mutate(new_price = ifelse(height >= 100, price + 100, price)) %>% 
  select(item_id, height, price, new_price)
```
Remember, you could also do this in-place by assigning the new column to "price" instead of "new_price".

#### Try it out

1. Create a new column that shows whether or not the word is in the first half of a sentence. If the word number is less than or equal to 3, this new column should read 'first half', if not, it should read 'second half'.
```{r}
spr %>% 
  mutate(sentence_half = ifelse(word_num <= 3, "first half", "second half"))
```

2. Create a new column that has the part of speech for a word. If the word is in following list, it should be labeled "content", otherwise, it should be labeled "function": c("practice", "sentence", "relative", "clause.", "cats.")
```{r}
spr %>% 
  mutate(POS = ifelse(word %in% c("practice", "sentence", "relative", "clause.", "cats."), "content", "function"))
```

3. Create a new column that shows how fast a word was read. First, find the mean reading time over the entire dataset. You can do this in the console most easily using the base-R syntax `mean(spr$RT)`. If the RT is greater than or equal to this number, your new column should read "slow", otherwise, it should read "fast". 
```{r}
mean(spr$RT)

spr %>% 
  mutate(fastness = ifelse(RT >= mean(spr$RT), "slow", "fast"))
```

![Case when: an extension of if-else](img/dplyr_case_when.png){width=50%}


![Group and ungroup](img/group_by_ungroup.png){width=50%}

# (11) Transforming data 

![Pivot](img/tidyr_spread_gather.png){width=50%}
## (11.1) pivot()
-> pivot (wide - long, or long - wide)
separate (example: tagged corpus text) and unite (example: create participant id from experiment id + number)

# (12) Joining several data sets
- left_join, right_join, inner_join, full_join
- semi_join, anti_join
- bind_rows, bind_cols


# (13) Writing files to disk

To write files to disk, you also need to select which separator you want to use -- do you want a comma-separated file or a tab-separated file? In theory, this shouldn't matter much,y ou just have to know which you pick. 

CSVs are often saved as .csv (this is also openable in Excel) and TSVs are often saved as .txt

You can save CSVs and TSVs like so:
```{r}
# write_tsv(spr_data, "spr_data_df.txt")

# write_csv(spr_data, "spr_data_df.csv")
```
Syntax: write_tsv(dfname, "filename.ext")

Remember, something like data type in R (ex: character or factor) can't be saved into one of these files -- it just saves the values separated by the separator (and the column names). So you'll still have to do the conversions next time you read the file into R. 


# (13) Simple graphs
- working with subsets by directly piping them into a plotting/model call

![ggplot2](img/ggplot2_exploratory.png){width=50%}

CHECK
- across  
- nest_by  
- recode, recode_factor  
- coalesce  
- lag and lead  
- cumulative aggregates  


# (14) Getting help

## Resources and cheat sheets
- [R for Data Science](https://r4ds.had.co.nz/index.html)
- [Collection of cheat sheets](https://rstudio.com/resources/cheatsheets/)

## How to access and read function documentations
?command/??command or enter it into the help search box

vingettes

## Reprex?

## Working with Google results

## Workflows/code conventions
-add- 


## Challenge questions / thinking tidyverse / chaining commands 
### Chaining commands

Thinking tidyverse: Now you have a lot of tidy tools that can all be combined or "chained".

See if you can figure out the following challenges. (Some may be a bit tricky, it's alright if you have to skip a couple or come back to them later.)

Penguins: 

1. Make a new column converting body mass to kg, then filter out all penguins under 6kg and save the result to a new tibble called "small_penguins".
```{r}

```

2. Which penguin species occur on Biscoe island? Filter first to include only this island, then return the distinct species that are found there. 
```{r}

```

3. Remember that the flipper_length column is represented in mm. Return how many penguins measured in this dataset had a flipper length longer than 2.5cm. Try to do this in one step, without having to permanently add the column to the dataframe (and without using 250cm)
```{r}

```


SPR: 
1. "Center" the response times around the average. This means take the mean RT and subtract it from every RT, so that 0 is now the average RT and the numbers reflect how much faster or slower the RT was from average. Save these centered RTs as a column called RT_c
```{r}

```

2. Create a new column that is called word_length and assign it to the number of characters in the word. Save the output.
```{r}

```

spr_data:
1. Return the most expensive bed.
```{r}

```

2. Count how many chairs are available in other colors.
```{r}

```


3. There is some junk in the designer column. Look at it using distinct(), then remove it with the following code: 

spr_data <- spr_data %>% 
  filter(!str_detect(designer, "[0-9]"))
  
Note: str_detect looks for regular expressions. Here, the regular expression [0-9] matches any number. If this is true, str_detect returns TRUE -- However, it is proceeded by ! which means NOT. Thus, the filter is satisfied only if str_detect returns FALSE, i.e. there are no numbers present.
  
Then, find which designer makes the most expensive furniture. Return the average price for each designer's products, and arrange them from largest to smallest. (Hint, give your summary column a name.)
```{r}

```


4. How many products did each designer design? You can use count, but can also just save this variable as a factor and look at a summary. 
```{r}

```



